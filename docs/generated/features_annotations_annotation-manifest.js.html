<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: features/annotations/annotation-manifest.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: features/annotations/annotation-manifest.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Video Annotation Data Structures
 * 
 * Provides core classes for managing video annotations:
 * - AnnotationManifest: Container for annotation collections with metadata
 * - Annotation: Individual annotation items with timing and type-specific data
 *
 * @module AnnotationManifest
 * 
 * @example
 * const manifest = new AnnotationManifest({
 *   metadata: { videoId: "abc123" },
 *   items: [
 *     new Annotation({
 *       id: "detection-1",
 *       type: "detection",
 *       timeRange: { startMs: 1000, endMs: 5000 },
 *       data: { bbox: { x: 0.1, y: 0.1, width: 0.2, height: 0.3 }, confidence: 0.95 }
 *     })
 *   ]
 * });
 */

/**
 * Individual annotation item with timing and type-specific data
 * 
 * @class Annotation
 * @property {string} id - Unique identifier
 * @property {string} type - Annotation type ('detection', 'text', 'graph', 'trajectory', 'cross')
 * @property {object} timeRange - Visibility window {startMs, endMs}
 * @property {object} data - Type-specific data
 * 
 * @example
 * const detection = new Annotation({
 *   id: 'det_001',
 *   type: 'detection',
 *   timeRange: { startMs: 1000, endMs: 5000 },
 *   data: { bbox: { x: 0.1, y: 0.1, width: 0.2, height: 0.3 }, confidence: 0.95, class: 'vehicle' }
 * });
 */
export class Annotation {
  /**
   * Creates a new annotation instance
   * 
   * @param {object} data - Annotation configuration
   * @param {string} data.id - Unique identifier
   * @param {string} data.type - Annotation type
   * @param {object} [data.timeRange={}] - Visibility range {startMs, endMs}
   * @param {object} [data.data={}] - Type-specific data
   * @throws {Error} When required fields are missing
   */
  constructor(data) {
    // Required fields
    this.id = data.id;
    this.type = data.type;
    this.timeRange = data.timeRange || {};
    this.data = data.data || {};

    // Validate required fields
    if (!this.id) {
      throw new Error("Annotation must have an id");
    }
    if (!this.type) {
      throw new Error("Annotation must have a type");
    }
  }

  /**
   * Check if annotation is visible at given time
   * 
   * @param {number} timeMs - Current video time in milliseconds
   * @returns {boolean} True if annotation is visible
   */
  isVisibleAt(timeMs) {
    if (!this.timeRange) return false;

    const { startMs = 0, endMs = Infinity } = this.timeRange;
    return timeMs >= startMs &amp;&amp; timeMs &lt;= endMs;
  }

  /**
   * Validate annotation structure and data integrity
   * 
   * @returns {boolean} True if annotation is valid
   */
  validate() {
    try {
      if (!this.id || typeof this.id !== "string") {
        throw new Error("Invalid annotation id");
      }

      if (!this.type || typeof this.type !== "string") {
        throw new Error("Invalid annotation type");
      }

      if (this.timeRange) {
        const { startMs, endMs } = this.timeRange;
        if (
          typeof startMs === "number" &amp;&amp;
          typeof endMs === "number" &amp;&amp;
          startMs > endMs
        ) {
          throw new Error("Invalid time range: startMs must be &lt;= endMs");
        }
      }

      return true;
    } catch (error) {
      console.warn(
        `Annotation validation failed for ${this.id}:`,
        error.message,
      );
      return false;
    }
  }

  /**
   * Convert annotation to JSON-serializable object
   * 
   * @returns {object} Serializable annotation data
   */
  toJSON() {
    return {
      id: this.id,
      type: this.type,
      timeRange: this.timeRange,
      data: this.data,
    };
  }

  /**
   * Create annotation from ML detection result
   * 
   * @param {object} detection - ML detection data
   * @param {string} id - Unique identifier
   * @param {object} timeRange - Visibility range
   * @returns {Annotation} Detection annotation
   */
  static fromDetection(detection, id, timeRange) {
    return new Annotation({
      id,
      type: "detection",
      timeRange,
      data: {
        bbox: detection.bbox,
        confidence: detection.confidence,
        class: detection.class,
        score: detection.score,
      },
    });
  }

  /**
   * Create text annotation
   * 
   * @param {string} text - Text content
   * @param {string} id - Unique identifier
   * @param {object} position - Position data
   * @param {object} timeRange - Visibility range
   * @returns {Annotation} Text annotation
   */
  static fromText(text, id, position, timeRange) {
    return new Annotation({
      id,
      type: "text",
      timeRange,
      data: {
        text,
        position,
        style: {
          fontSize: "16px",
          color: "#ffffff",
          backgroundColor: "rgba(0, 0, 0, 0.7)",
        },
      },
    });
  }
}

/**
 * Container for annotation collections with metadata and versioning
 * 
 * @class AnnotationManifest
 * @property {string} version - Schema version
 * @property {object} metadata - Document metadata
 * @property {Annotation[]} items - Annotation collection
 * 
 * @example
 * const manifest = new AnnotationManifest({
 *   version: "1.0",
 *   metadata: { videoId: "abc123" },
 *   items: [annotation1, annotation2]
 * });
 */
export class AnnotationManifest {
  /**
   * Creates annotation manifest with items and metadata
   * 
   * @param {object} [data={}] - Manifest configuration
   * @param {string} [data.version="1.0"] - Schema version
   * @param {object} [data.metadata={}] - Document metadata
   * @param {Annotation[]|object[]} [data.items=[]] - Annotations array
   */
  constructor(data = {}) {
    this.version = data.version || "1.0";
    this.metadata = data.metadata || {};
    this.items = [];

    // Process items array
    if (data.items &amp;&amp; Array.isArray(data.items)) {
      this.items = data.items.map((item) =>
        item instanceof Annotation ? item : new Annotation(item),
      );
    }
  }

  /**
   * Add annotation item to manifest
   * @param {Annotation|object} annotation - Annotation to add
   */
  addItem(annotation) {
    const annotationObj =
      annotation instanceof Annotation
        ? annotation
        : new Annotation(annotation);

    this.items.push(annotationObj);
  }

  /**
   * Remove annotation by ID
   * @param {string} id - Annotation ID to remove
   * @returns {boolean} - True if removed, false if not found
   */
  removeItem(id) {
    const initialLength = this.items.length;
    this.items = this.items.filter((item) => item.id !== id);
    return this.items.length &lt; initialLength;
  }

  /**
   * Get all annotations visible at given time
   * @param {number} timeMs - Current video time in milliseconds
   * @returns {Annotation[]}
   */
  getItemsAtTime(timeMs) {
    return this.items.filter((item) => item.isVisibleAt(timeMs));
  }

  /**
   * Find annotation by ID
   * @param {string} id - Annotation ID
   * @returns {Annotation|null}
   */
  findById(id) {
    return this.items.find((item) => item.id === id) || null;
  }

  /**
   * Get all annotations of specific type
   * @param {string} type - Annotation type
   * @returns {Annotation[]}
   */
  getItemsByType(type) {
    return this.items.filter((item) => item.type === type);
  }

  /**
   * Clear all annotations
   */
  clear() {
    this.items = [];
  }

  /**
   * Get count of annotations
   * @returns {number}
   */
  get count() {
    return this.items.length;
  }

  /**
   * Validate entire manifest
   * @returns {boolean}
   */
  validate() {
    try {
      if (!this.version || typeof this.version !== "string") {
        throw new Error("Invalid manifest version");
      }

      if (!Array.isArray(this.items)) {
        throw new Error("Items must be an array");
      }

      // Validate each annotation
      for (const item of this.items) {
        if (!item.validate()) {
          return false;
        }
      }

      return true;
    } catch (error) {
      console.warn("Manifest validation failed:", error.message);
      return false;
    }
  }

  /**
   * Convert to JSON-serializable object
   * @returns {object}
   */
  toJSON() {
    return {
      version: this.version,
      metadata: this.metadata,
      items: this.items.map((item) => item.toJSON()),
    };
  }

  /**
   * Create manifest from JSON data
   * @param {object} jsonData - JSON data
   * @returns {AnnotationManifest}
   */
  static fromJSON(jsonData) {
    return new AnnotationManifest(jsonData);
  }

  /**
   * Create empty manifest with metadata
   * @param {object} metadata - Metadata object
   * @returns {AnnotationManifest}
   */
  static create(metadata = {}) {
    return new AnnotationManifest({
      version: "1.0",
      metadata,
      items: [],
    });
  }

  /**
   * Create manifest from ML detection results
   * @param {object[]} detections - Array of ML detection results
   * @param {object} metadata - Metadata object
   * @returns {AnnotationManifest}
   */
  static fromDetections(detections, metadata = {}) {
    const manifest = AnnotationManifest.create(metadata);

    detections.forEach((detection, index) => {
      const annotation = Annotation.fromDetection(
        detection,
        `detection-${index}`,
        detection.timeRange || { startMs: 0, endMs: 5000 },
      );
      manifest.addItem(annotation);
    });

    return manifest;
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-AnnotationManifest.html">AnnotationManifest</a></li></ul><h3>Classes</h3><ul><li><a href="Application.html">Application</a></li><li><a href="GlobalScope.html">GlobalScope</a></li><li><a href="module-AnnotationManifest.Annotation.html">Annotation</a></li><li><a href="module-AnnotationManifest.AnnotationManifest.html">AnnotationManifest</a></li><li><a href="module-AnnotationManifest-Annotation.html">Annotation</a></li><li><a href="module-AnnotationManifest-AnnotationManifest.html">AnnotationManifest</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AnnotationSamples">AnnotationSamples</a></li><li><a href="global.html#KeyboardHelpGenerator">KeyboardHelpGenerator</a></li><li><a href="global.html#NotepadUI">NotepadUI</a></li><li><a href="global.html#RenderingDebug">RenderingDebug</a></li><li><a href="global.html#SystemDebug">SystemDebug</a></li><li><a href="global.html#UIManager">UIManager</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Jul 20 2025 16:25:40 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
